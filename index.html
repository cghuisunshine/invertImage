<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Invert Image</title>
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  body { margin: 24px; }
  .box { border: 2px dashed #bbb; border-radius: 12px; padding: 24px; text-align: center; transition: border-color .2s; }
  .box.dragover { border-color: #333; }
  .row { display: grid; gap: 16px; grid-template-columns: 1fr; margin-top: 16px; }
  @media (min-width: 900px) { .row { grid-template-columns: 1fr 1fr; } }
  canvas, img { max-width: 100%; border-radius: 8px; background: #f6f6f6; }
  .actions { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin-top: 12px; }
  button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ddd; cursor: pointer; }
  input[type=file] { display: none; }
  .hint { color:#666; font-size: .95rem; }
  .controls { display:flex; gap:14px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:12px; }
  label.inline { display:flex; gap:8px; align-items:center; cursor:pointer; user-select:none; }
  .sliders { display:grid; gap:8px; grid-template-columns: 1fr; max-width: 700px; margin: 10px auto 0; }
  .slider-row { display:grid; grid-template-columns: 180px 1fr 64px; gap:10px; align-items:center; }
  .slider-row input[type=number] { width:64px; padding:6px; border:1px solid #ddd; border-radius:8px; }
  .disabled { opacity:.6; pointer-events:none; }
</style>
</head>
<body>
  <h1>Invert Image</h1>
  <p class="hint">Upload, drag & drop, or <strong>Ctrl/⌘+V</strong> paste an image.</p>

  <div class="controls">
    <label>
      <button id="pickBtn">Choose image…</button>
      <!-- accept now includes HEIC/HEIF -->
      <input id="fileInput" type="file" accept="image/*,.heic,.heif">
    </label>

    <label class="inline" title="Invert the image colors. Disable to show the original (rotation still applies).">
      <input id="enableInvert" type="checkbox" checked>
      Invert colors
    </label>

    <label class="inline" title="Snap near-black to pure black and near-white to pure white on the original, then invert.">
      <input id="preSnap" type="checkbox">
      Snap extremes before invert
    </label>

    <label class="inline" title="Rotate the RESULT image by 180° after processing.">
      <input id="rotate180" type="checkbox">
      Rotate 180°
    </label>

    <button id="resetBtn" type="button" title="Reset thresholds to defaults">Reset thresholds</button>
  </div>

  <div class="sliders" aria-label="threshold controls" id="slidersWrap">
    <div class="slider-row">
      <span>Near-black threshold</span>
      <input id="lowRange" type="range" min="0" max="255" step="1">
      <input id="lowNum" type="number" min="0" max="255" step="1">
    </div>
    <div class="slider-row">
      <span>Near-white threshold</span>
      <input id="highRange" type="range" min="0" max="255" step="1">
      <input id="highNum" type="number" min="0" max="255" step="1">
    </div>
  </div>

  <div id="dropZone" class="box" aria-label="drop zone">
    Drop image here or paste from clipboard
  </div>

  <div class="row">
    <div>
      <h3>Original</h3>
      <img id="original" alt="original preview" />
    </div>
    <div>
      <h3>Result</h3>
      <canvas id="canvas"></canvas>
      <div class="actions">
        <button id="downloadBtn" disabled>Download image</button>
        <button id="copyBtn" disabled>Copy to clipboard</button>
      </div>
      <p class="hint" id="info"></p>
    </div>
  </div>

<script>
const fileInput = document.getElementById('fileInput');
const dropZone  = document.getElementById('dropZone');
const pickBtn   = document.getElementById('pickBtn');
const original  = document.getElementById('original');
const canvas    = document.getElementById('canvas');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn     = document.getElementById('copyBtn');
const info        = document.getElementById('info');
const enableInvert = document.getElementById('enableInvert');
const preSnap     = document.getElementById('preSnap');
const rotate180   = document.getElementById('rotate180');
const resetBtn    = document.getElementById('resetBtn');

const lowRange = document.getElementById('lowRange');
const highRange = document.getElementById('highRange');
const lowNum = document.getElementById('lowNum');
const highNum = document.getElementById('highNum');
const slidersWrap = document.getElementById('slidersWrap');

const ctx = canvas.getContext('2d', { willReadFrequently: true });

let currentFileName = 'image';
let originalPixels = null;
let sourceWasHeic = false; // NEW

// Defaults
const DEFAULT_LOW  = 26;   // ~10%
const DEFAULT_HIGH = 229;  // ~90%

function loadSettings() {
  const savedLow = localStorage.getItem('thresholdLow');
  const savedHigh = localStorage.getItem('thresholdHigh');
  const savedSnap = localStorage.getItem('snapEnabled');
  const savedRotate = localStorage.getItem('rotateEnabled');
  const savedInvert = localStorage.getItem('invertEnabled');
  const low = savedLow !== null ? parseInt(savedLow, 10) : DEFAULT_LOW;
  const high = savedHigh !== null ? parseInt(savedHigh, 10) : DEFAULT_HIGH;
  setThresholds(low, high);
  enableInvert.checked = savedInvert === null ? true : savedInvert === 'true';
  preSnap.checked = savedSnap === null ? true : savedSnap === 'true';
  rotate180.checked = savedRotate === 'true';
  updateDisabledState();
}

function saveSettings() {
  const [low, high] = getThresholds();
  localStorage.setItem('thresholdLow', low);
  localStorage.setItem('thresholdHigh', high);
  localStorage.setItem('invertEnabled', enableInvert.checked);
  localStorage.setItem('snapEnabled', preSnap.checked);
  localStorage.setItem('rotateEnabled', rotate180.checked);
}

pickBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => handleFiles(e.target.files));

enableInvert.addEventListener('change', () => { updateDisabledState(); saveSettings(); applyProcessing(); });
preSnap.addEventListener('change', () => { saveSettings(); applyProcessing(); });
rotate180.addEventListener('change', () => { saveSettings(); applyProcessing(); });
resetBtn.addEventListener('click', () => { setThresholds(DEFAULT_LOW, DEFAULT_HIGH); saveSettings(); applyProcessing(); });

['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, e => {
  e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover');
}));
['dragleave','drop'].forEach(ev => dropZone.addEventListener(ev, e => {
  e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover');
}));
dropZone.addEventListener('drop', e => {
  const files = e.dataTransfer.files;
  if (files && files.length) handleFiles(files);
});

document.addEventListener('paste', async (e) => {
  const items = e.clipboardData?.items || [];
  for (const it of items) {
    if (it.type.startsWith('image/')) {
      const blob = it.getAsFile();
      currentFileName = 'pasted';
      await loadAnyImageBlob(blob, /*filenameHint*/'pasted');
      break;
    }
  }
});

// --- slider wiring
function setThresholds(low, high) {
  low = Math.max(0, Math.min(255, Math.round(low)));
  high = Math.max(0, Math.min(255, Math.round(high)));
  if (low > high) [low, high] = [high, low];
  lowRange.value = lowNum.value = low;
  highRange.value = highNum.value = high;
}

function getThresholds() {
  const low = parseInt(lowRange.value, 10);
  const high = parseInt(highRange.value, 10);
  return [Math.min(low, high), Math.max(low, high)];
}

[lowRange, lowNum, highRange, highNum].forEach(el => {
  el.addEventListener('input', () => {
    if (el === lowRange) lowNum.value = lowRange.value;
    if (el === lowNum)   lowRange.value = lowNum.value;
    if (el === highRange) highNum.value = highRange.value;
    if (el === highNum)   highRange.value = highNum.value;
    const [low, high] = getThresholds();
    setThresholds(low, high);
    saveSettings();
    applyProcessing();
  });
});

function updateDisabledState() {
  const on = enableInvert.checked;
  preSnap.disabled = !on;
  resetBtn.disabled = !on;
  lowRange.disabled = lowNum.disabled = !on;
  highRange.disabled = highNum.disabled = !on;
  slidersWrap.classList.toggle('disabled', !on);
}

// ===== HEIC SUPPORT =====

// lightweight loader for heic2any only when needed
async function ensureHeicDecoder() {
  if (window.heic2any) return window.heic2any;
  await new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js';
    s.async = true;
    s.onload = () => resolve();
    s.onerror = () => reject(new Error('Failed to load HEIC decoder.'));
    document.head.appendChild(s);
  });
  if (!window.heic2any) throw new Error('HEIC decoder unavailable.');
  return window.heic2any;
}

function looksLikeHeic(file, filenameHint = '') {
  const t = (file.type || '').toLowerCase();
  const n = (file.name || filenameHint || '').toLowerCase();
  return t === 'image/heic' || t === 'image/heif' || n.endsWith('.heic') || n.endsWith('.heif');
}

async function handleFiles(fileList) {
  const file = fileList[0];
  if (!file) return;
  const base = file.name ? file.name.replace(/\.[^.]+$/, '') : 'image';
  currentFileName = base || 'image';
  await loadAnyImageBlob(file, file.name);
}

async function loadAnyImageBlob(fileOrBlob, filenameHint='') {
  info.textContent = '';
  downloadBtn.disabled = true; copyBtn.disabled = true;

  try {
    let blob = fileOrBlob;
    sourceWasHeic = false;

    if (blob instanceof File && looksLikeHeic(blob, filenameHint)) {
      // Decode to PNG first
      const heic2any = await ensureHeicDecoder();
      const out = await heic2any({ blob, toType: 'image/png' });
      // heic2any may return a Blob or an array of Blobs (for HEIC sequences/live photos)
      blob = Array.isArray(out) ? out[0] : out;
      sourceWasHeic = true;
    }

    await loadBlobAsDrawable(blob);
    downloadBtn.disabled = false;
    copyBtn.disabled = !('ClipboardItem' in window && navigator.clipboard?.write);
  } catch (err) {
    console.error(err);
    info.textContent = 'Could not process this image.';
  }
}

// Draw any (already-compatible) blob onto canvas and keep originalPixels
async function loadBlobAsDrawable(blob) {
  const url = URL.createObjectURL(blob);
  try {
    const bmp = await createImageBitmap(blob, { imageOrientation: 'from-image' });
    canvas.width = bmp.width; canvas.height = bmp.height;
    const tmpctx = canvas.getContext('2d');
    tmpctx.drawImage(bmp, 0, 0);
    original.src = canvas.toDataURL('image/png');
    originalPixels = tmpctx.getImageData(0, 0, canvas.width, canvas.height);
    applyProcessing();
  } finally {
    URL.revokeObjectURL(url);
  }
}

// Process: (optional invert with optional snap) -> (optional) rotate 180°
function applyProcessing() {
  if (!originalPixels) return;

  const w = originalPixels.width, h = originalPixels.height;
  const [LOW_LUMA, HIGH_LUMA] = getThresholds();
  const doInvert = enableInvert.checked;
  const doSnap = preSnap.checked && doInvert;

  let out;

  if (doInvert) {
    const src = originalPixels.data;
    out = ctx.createImageData(w, h);
    const d = out.data;

    for (let i = 0; i < src.length; i += 4) {
      let r = src[i], g = src[i+1], b = src[i+2];
      const a = src[i+3];

      if (doSnap) {
        const L = 0.2126*r + 0.7152*g + 0.0722*b;
        if (L < LOW_LUMA) {
          r = g = b = 0;
        } else if (L > HIGH_LUMA) {
          r = g = b = 255;
        }
      }

      d[i]   = 255 - r;
      d[i+1] = 255 - g;
      d[i+2] = 255 - b;
      d[i+3] = a;
    }
  } else {
    out = new ImageData(new Uint8ClampedArray(originalPixels.data), w, h);
  }

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, w, h);

  if (rotate180.checked) {
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    tctx.putImageData(out, 0, 0);

    ctx.save();
    ctx.translate(w, h);
    ctx.rotate(Math.PI);
    ctx.drawImage(tmp, 0, 0);
    ctx.restore();
  } else {
    ctx.putImageData(out, 0, 0);
  }

  const invertTag = doInvert ? ' • inverted' : ' • no invert';
  const snapTag = doSnap ? ` • snap[${LOW_LUMA}, ${HIGH_LUMA}]` : '';
  const rotTag = rotate180.checked ? ' • rotated 180°' : '';
  const heicTag = sourceWasHeic ? ' • source: HEIC' : '';
  info.textContent = `${w}×${h}px${invertTag}${snapTag}${rotTag}${heicTag}`;
}

downloadBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  // If source was HEIC or user wants PNG output, force .png (your pipeline is PNG anyway)
  const name = `${currentFileName}-${enableInvert.checked ? 'inverted' : 'original'}.png`;
  a.download = name;
  a.click();
});

copyBtn.addEventListener('click', async () => {
  try {
    const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    info.textContent = 'Copied to clipboard ✔';
  } catch {
    info.textContent = 'Copy failed (browser blocked).';
  }
});

loadSettings();
</script>
</body>
</html>

